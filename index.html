<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HACK THE PLANET - 30th Anniversary Tribute</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            cursor: none;
        }
        
        #canvas {
            display: block;
            background: #000;
        }
        
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .scanline {
            position: absolute;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #00ff00, transparent);
            animation: scan 3s linear infinite;
        }
        
        @keyframes scan {
            0% { top: -2px; opacity: 0; }
            50% { opacity: 1; }
            100% { top: 100vh; opacity: 0; }
        }
        
        .glitch {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            color: #00ff00;
            text-shadow: 
                2px 0 #ff0000,
                -2px 0 #0000ff,
                0 2px #ff0000,
                0 -2px #0000ff;
            animation: glitch 0.3s infinite;
            white-space: nowrap;
        }
        
        @keyframes glitch {
            0%, 100% { transform: translate(-50%, -50%); }
            20% { transform: translate(-48%, -52%); }
            40% { transform: translate(-52%, -48%); }
            60% { transform: translate(-50%, -50%); }
            80% { transform: translate(-49%, -51%); }
        }
        
        .matrix-text {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ff00;
            font-size: 0.8rem;
            line-height: 1.2;
            opacity: 0.8;
        }
        
        .terminal {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #00ff00;
            font-size: 0.7rem;
            font-family: 'Courier New', monospace;
            opacity: 0.9;
        }
        
        .cursor {
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .audio-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #00ff00;
            font-size: 0.7rem;
            font-family: 'Courier New', monospace;
            z-index: 20;
        }
        
        .audio-controls button {
            background: transparent;
            border: 1px solid #00ff00;
            color: #00ff00;
            padding: 5px 10px;
            margin: 2px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .audio-controls button:hover {
            background: #00ff00;
            color: #000;
        }
        
        .audio-controls button.active {
            background: #00ff00;
            color: #000;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="overlay">
        <div class="scanline"></div>
        
        <div class="glitch" id="title">
            HACK THE PLANET
        </div>
        
        <div class="matrix-text" id="matrixText">
            <div>INITIALIZING NEURAL NETWORK...</div>
            <div>ACCESSING MAINFRAME...</div>
            <div>BREACHING FIREWALL...</div>
            <div>DOWNLOADING DATA...</div>
        </div>
        
        <div class="terminal" id="terminal">
            <div>root@hackers:~$ whoami</div>
            <div>zero_cool</div>
            <div>root@hackers:~$ date</div>
            <div id="currentDate"></div>
            <div>root@hackers:~$ <span class="cursor">█</span></div>
        </div>
        
        <div class="audio-controls">
            <div>MIDI AUDIO SYSTEM</div>
            <button id="playBtn">PLAY</button>
            <button id="stopBtn">STOP</button>
            <button id="volBtn">VOL: 50%</button>
        </div>
    </div>

    <script>
        // MIDI Synthesizer for Cyberpunk Soundtrack
        class CyberpunkMIDI {
            constructor() {
                this.audioContext = null;
                this.isPlaying = false;
                this.volume = 0.5;
                this.tempo = 120; // BPM
                this.currentBeat = 0;
                this.patterns = this.createPatterns();
                this.oscillators = [];
                this.gainNode = null;
                this.masterGain = null;
            }
            
            async init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.connect(this.audioContext.destination);
                    this.masterGain.gain.value = this.volume;
                    
                    // Create synthesizer patterns inspired by Hackers soundtrack
                    this.createCyberpunkPatterns();
                    
                    return true;
                } catch (error) {
                    console.log('Audio not available:', error);
                    return false;
                }
            }
            
            createCyberpunkPatterns() {
                // Inspired by Orbital, Underworld, and 90s electronic music
                this.patterns = {
                    bass: [36, 0, 36, 0, 36, 0, 36, 0, 36, 0, 36, 0, 36, 0, 36, 0], // Deep bass line
                    lead: [60, 0, 64, 0, 67, 0, 72, 0, 0, 0, 0, 0, 60, 64, 67, 72], // Melodic lead
                    pad: [48, 51, 55, 58, 60, 63, 67, 70, 72, 75, 79, 82, 84, 87, 91, 94], // Ambient pad
                    drums: [38, 0, 42, 0, 38, 42, 0, 42, 38, 0, 42, 0, 38, 42, 38, 42], // Electronic drums
                    arp: [72, 79, 84, 91, 84, 79, 72, 67, 72, 79, 84, 91, 96, 91, 84, 79] // Arpeggiated sequence
                };
            }
            
            play() {
                if (!this.audioContext || this.isPlaying) return;
                
                this.isPlaying = true;
                this.currentBeat = 0;
                this.startSequencer();
            }
            
            stop() {
                this.isPlaying = false;
                this.oscillators.forEach(osc => {
                    if (osc) osc.stop();
                });
                this.oscillators = [];
            }
            
            startSequencer() {
                if (!this.isPlaying) return;
                
                const beatDuration = (60 / this.tempo) * 4; // 16th note duration
                
                // Play all patterns
                Object.keys(this.patterns).forEach((patternName, index) => {
                    const note = this.patterns[patternName][this.currentBeat % this.patterns[patternName].length];
                    if (note > 0) {
                        this.playNote(note, patternName, index * 0.1);
                    }
                });
                
                this.currentBeat++;
                setTimeout(() => this.startSequencer(), beatDuration * 1000);
            }
            
            playNote(midiNote, instrument, delay = 0) {
                if (!this.audioContext) return;
                
                const frequency = 440 * Math.pow(2, (midiNote - 69) / 12);
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                // Different waveforms for different instruments
                let waveform = 'sine';
                let attack = 0.01;
                let decay = 0.3;
                let sustain = 0.7;
                let release = 0.5;
                
                switch (instrument) {
                    case 'bass':
                        waveform = 'sawtooth';
                        attack = 0.1;
                        decay = 0.2;
                        sustain = 0.8;
                        release = 0.3;
                        break;
                    case 'lead':
                        waveform = 'square';
                        attack = 0.05;
                        decay = 0.1;
                        sustain = 0.9;
                        release = 0.2;
                        break;
                    case 'pad':
                        waveform = 'triangle';
                        attack = 0.5;
                        decay = 0.3;
                        sustain = 0.8;
                        release = 1.0;
                        break;
                    case 'drums':
                        waveform = 'square';
                        attack = 0.001;
                        decay = 0.1;
                        sustain = 0.0;
                        release = 0.1;
                        break;
                    case 'arp':
                        waveform = 'sine';
                        attack = 0.01;
                        decay = 0.1;
                        sustain = 0.7;
                        release = 0.2;
                        break;
                }
                
                oscillator.type = waveform;
                oscillator.frequency.value = frequency;
                
                // ADSR envelope
                const now = this.audioContext.currentTime + delay;
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(sustain, now + attack);
                gainNode.gain.linearRampToValueAtTime(sustain * 0.7, now + attack + decay);
                gainNode.gain.linearRampToValueAtTime(0, now + attack + decay + release);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.masterGain);
                
                oscillator.start(now);
                oscillator.stop(now + attack + decay + release);
                
                this.oscillators.push(oscillator);
            }
            
            setVolume(volume) {
                this.volume = Math.max(0, Math.min(1, volume));
                if (this.masterGain) {
                    this.masterGain.gain.value = this.volume;
                }
            }
        }

        class HackersTribute {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.time = 0;
                this.particles = [];
                this.wireframe = [];
                this.plasma = [];
                this.matrix = [];
                this.midi = new CyberpunkMIDI();
                
                this.init();
                this.createParticles();
                this.createWireframe();
                this.createMatrix();
                this.setupAudioControls();
                this.animate();
                
                // Update date
                document.getElementById('currentDate').textContent = new Date().toLocaleString();
            }
            
            init() {
                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                // Add some interactive elements
                this.canvas.addEventListener('click', () => this.explosion());
                this.canvas.addEventListener('mousemove', (e) => this.mouseMove(e));
                
                // Initialize MIDI
                this.midi.init();
            }
            
            setupAudioControls() {
                const playBtn = document.getElementById('playBtn');
                const stopBtn = document.getElementById('stopBtn');
                const volBtn = document.getElementById('volBtn');
                
                playBtn.addEventListener('click', () => {
                    if (this.midi.isPlaying) {
                        this.midi.stop();
                        playBtn.textContent = 'PLAY';
                        playBtn.classList.remove('active');
                    } else {
                        this.midi.play();
                        playBtn.textContent = 'PAUSE';
                        playBtn.classList.add('active');
                    }
                });
                
                stopBtn.addEventListener('click', () => {
                    this.midi.stop();
                    playBtn.textContent = 'PLAY';
                    playBtn.classList.remove('active');
                });
                
                volBtn.addEventListener('click', () => {
                    const volumes = [0, 0.25, 0.5, 0.75, 1.0];
                    const currentVol = this.midi.volume;
                    const currentIndex = volumes.indexOf(currentVol);
                    const nextIndex = (currentIndex + 1) % volumes.length;
                    const newVol = volumes[nextIndex];
                    
                    this.midi.setVolume(newVol);
                    volBtn.textContent = `VOL: ${Math.round(newVol * 100)}%`;
                });
            }
            
            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }
            
            createParticles() {
                for (let i = 0; i < 200; i++) {
                    this.particles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        life: Math.random() * 100,
                        maxLife: 100,
                        size: Math.random() * 3 + 1
                    });
                }
            }
            
            createWireframe() {
                // Create a 3D wireframe cube
                const size = 100;
                const vertices = [
                    [-size, -size, -size], [size, -size, -size], [size, size, -size], [-size, size, -size],
                    [-size, -size, size], [size, -size, size], [size, size, size], [-size, size, size]
                ];
                
                const edges = [
                    [0,1], [1,2], [2,3], [3,0], // front face
                    [4,5], [5,6], [6,7], [7,4], // back face
                    [0,4], [1,5], [2,6], [3,7]  // connecting edges
                ];
                
                this.wireframe = { vertices, edges };
            }
            
            createMatrix() {
                const chars = '01アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン';
                for (let i = 0; i < 50; i++) {
                    this.matrix.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        char: chars[Math.floor(Math.random() * chars.length)],
                        speed: Math.random() * 2 + 1,
                        life: Math.random() * 100
                    });
                }
            }
            
            mouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Create particles at mouse position
                for (let i = 0; i < 5; i++) {
                    this.particles.push({
                        x: mouseX + (Math.random() - 0.5) * 20,
                        y: mouseY + (Math.random() - 0.5) * 20,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 60,
                        maxLife: 60,
                        size: Math.random() * 2 + 1
                    });
                }
            }
            
            explosion() {
                // Create explosion effect
                for (let i = 0; i < 100; i++) {
                    const angle = (Math.PI * 2 * i) / 100;
                    this.particles.push({
                        x: this.canvas.width / 2,
                        y: this.canvas.height / 2,
                        vx: Math.cos(angle) * 8,
                        vy: Math.sin(angle) * 8,
                        life: 80,
                        maxLife: 80,
                        size: Math.random() * 4 + 2
                    });
                }
            }
            
            drawPlasma(musicIntensity = 1.0) {
                const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                for (let y = 0; y < this.canvas.height; y += 2) {
                    for (let x = 0; x < this.canvas.width; x += 2) {
                        const index = (y * this.canvas.width + x) * 4;
                        
                        const timeMultiplier = 0.01 * musicIntensity;
                        const value1 = Math.sin((x * 0.01) + this.time * timeMultiplier);
                        const value2 = Math.sin((y * 0.01) + this.time * timeMultiplier);
                        const value3 = Math.sin(((x + y) * 0.01) + this.time * timeMultiplier);
                        const value4 = Math.sin((Math.sqrt(x * x + y * y) * 0.01) + this.time * timeMultiplier);
                        
                        const value = (value1 + value2 + value3 + value4) / 4;
                        
                        const r = Math.floor((Math.sin(value * Math.PI) + 1) * 127 * musicIntensity);
                        const g = Math.floor((Math.sin(value * Math.PI + 2) + 1) * 127 * musicIntensity);
                        const b = Math.floor((Math.sin(value * Math.PI + 4) + 1) * 127 * musicIntensity);
                        
                        data[index] = Math.min(255, r);
                        data[index + 1] = Math.min(255, g);
                        data[index + 2] = Math.min(255, b);
                        data[index + 3] = 255;
                    }
                }
                
                this.ctx.putImageData(imageData, 0, 0);
            }
            
            drawWireframe(beatSync = 0) {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const rotation = this.time * 0.01 + (beatSync * 0.1);
                
                // Pulsing effect synchronized with beat
                const pulseIntensity = Math.sin(beatSync * Math.PI / 8) * 0.5 + 0.5;
                this.ctx.strokeStyle = `rgba(0, 255, 0, ${0.8 + pulseIntensity * 0.2})`;
                this.ctx.lineWidth = 1 + pulseIntensity;
                this.ctx.beginPath();
                
                const vertices = this.wireframe.vertices.map(vertex => {
                    const [x, y, z] = vertex;
                    const rotatedX = x * Math.cos(rotation) - z * Math.sin(rotation);
                    const rotatedZ = x * Math.sin(rotation) + z * Math.cos(rotation);
                    const rotatedY = y * Math.cos(rotation * 0.7) - rotatedZ * Math.sin(rotation * 0.7);
                    
                    const scale = 300 / (300 + rotatedZ);
                    const screenX = centerX + rotatedX * scale;
                    const screenY = centerY + rotatedY * scale;
                    
                    return [screenX, screenY];
                });
                
                this.wireframe.edges.forEach(edge => {
                    const [start, end] = edge;
                    const [x1, y1] = vertices[start];
                    const [x2, y2] = vertices[end];
                    
                    this.ctx.moveTo(x1, y1);
                    this.ctx.lineTo(x2, y2);
                });
                
                this.ctx.stroke();
            }
            
            drawParticles() {
                this.particles.forEach((particle, index) => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.life--;
                    
                    if (particle.life <= 0 || particle.x < 0 || particle.x > this.canvas.width || 
                        particle.y < 0 || particle.y > this.canvas.height) {
                        this.particles.splice(index, 1);
                        return;
                    }
                    
                    const alpha = particle.life / particle.maxLife;
                    this.ctx.fillStyle = `rgba(0, 255, 0, ${alpha})`;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }
            
            drawMatrix() {
                this.ctx.font = '12px Courier New';
                this.ctx.fillStyle = '#00ff00';
                
                this.matrix.forEach(char => {
                    char.y += char.speed;
                    char.life--;
                    
                    if (char.y > this.canvas.height || char.life <= 0) {
                        char.y = -20;
                        char.x = Math.random() * this.canvas.width;
                        char.life = Math.random() * 100 + 50;
                    }
                    
                    const alpha = char.life / 150;
                    this.ctx.globalAlpha = alpha;
                    this.ctx.fillText(char.char, char.x, char.y);
                });
                
                this.ctx.globalAlpha = 1;
            }
            
            drawTunnel(musicIntensity = 1.0) {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const maxRadius = Math.max(this.canvas.width, this.canvas.height) / 2;
                
                for (let i = 0; i < 50; i++) {
                    const radius = (i / 50) * maxRadius;
                    const angle = (this.time * 0.02 * musicIntensity) + (i * 0.1);
                    
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    const alpha = (1 - i / 50) * musicIntensity;
                    this.ctx.strokeStyle = `rgba(0, 255, 0, ${alpha})`;
                    this.ctx.lineWidth = 2 * musicIntensity;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 2 * musicIntensity, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
            }
            
            animate() {
                this.time++;
                
                // Sync visual intensity with music
                const musicIntensity = this.midi.isPlaying ? 1.5 : 1.0;
                const beatSync = this.midi.currentBeat % 16;
                
                // Clear canvas with fade effect
                this.ctx.fillStyle = `rgba(0, 0, 0, ${0.1 / musicIntensity})`;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw effects in layers with music sync
                this.drawPlasma(musicIntensity);
                this.drawWireframe(beatSync);
                this.drawTunnel(musicIntensity);
                this.drawParticles();
                this.drawMatrix();
                
                // Enhanced glitch effects when music is playing
                if (this.midi.isPlaying && Math.random() < 0.05) {
                    this.glitchEffect();
                } else if (!this.midi.isPlaying && Math.random() < 0.02) {
                    this.glitchEffect();
                }
                
                requestAnimationFrame(() => this.animate());
            }
            
            glitchEffect() {
                const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                // Randomly shift some pixel rows
                for (let i = 0; i < 10; i++) {
                    const row = Math.floor(Math.random() * this.canvas.height);
                    const shift = Math.floor((Math.random() - 0.5) * 50);
                    
                    for (let x = 0; x < this.canvas.width; x++) {
                        const sourceIndex = (row * this.canvas.width + x) * 4;
                        const targetIndex = (row * this.canvas.width + ((x + shift + this.canvas.width) % this.canvas.width)) * 4;
                        
                        data[targetIndex] = data[sourceIndex];
                        data[targetIndex + 1] = data[sourceIndex + 1];
                        data[targetIndex + 2] = data[sourceIndex + 2];
                    }
                }
                
                this.ctx.putImageData(imageData, 0, 0);
            }
        }
        
        // Initialize the tribute when page loads
        window.addEventListener('load', () => {
            new HackersTribute();
        });
        
        // Easter egg: Konami code
        let konamiCode = [];
        const konamiSequence = [38, 38, 40, 40, 37, 39, 37, 39, 66, 65]; // ↑↑↓↓←→←→BA
        
        document.addEventListener('keydown', (e) => {
            konamiCode.push(e.keyCode);
            if (konamiCode.length > konamiSequence.length) {
                konamiCode.shift();
            }
            
            if (konamiCode.join(',') === konamiSequence.join(',')) {
                alert('ACCESS GRANTED\n\n"Mess with the best, die like the rest!"\n\n- Zero Cool');
                konamiCode = [];
            }
        });
    </script>
</body>
</html>
