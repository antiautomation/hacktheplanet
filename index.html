<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HACK THE PLANET - 30th Anniversary Tribute</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            cursor: none;
        }
        
        #canvas {
            display: block;
            background: #000;
        }
        
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .scanline {
            position: absolute;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #00ff00, transparent);
            animation: scan 3s linear infinite;
        }
        
        @keyframes scan {
            0% { top: -2px; opacity: 0; }
            50% { opacity: 1; }
            100% { top: 100vh; opacity: 0; }
        }
        
        .glitch {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            color: #00ff00;
            text-shadow: 
                2px 0 #ff0000,
                -2px 0 #0000ff,
                0 2px #ff0000,
                0 -2px #0000ff;
            animation: glitch 0.3s infinite;
            white-space: nowrap;
        }
        
        @keyframes glitch {
            0%, 100% { transform: translate(-50%, -50%); }
            20% { transform: translate(-48%, -52%); }
            40% { transform: translate(-52%, -48%); }
            60% { transform: translate(-50%, -50%); }
            80% { transform: translate(-49%, -51%); }
        }
        
        .matrix-text {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ff00;
            font-size: 0.8rem;
            line-height: 1.2;
            opacity: 0.8;
        }
        
        .terminal {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #00ff00;
            font-size: 0.7rem;
            font-family: 'Courier New', monospace;
            opacity: 0.9;
        }
        
        .cursor {
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .audio-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #00ff00;
            font-size: 0.7rem;
            font-family: 'Courier New', monospace;
            z-index: 20;
            pointer-events: auto;
        }
        
        .audio-controls button {
            background: transparent;
            border: 1px solid #00ff00;
            color: #00ff00;
            padding: 5px 10px;
            margin: 2px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .audio-controls button:hover {
            background: #00ff00;
            color: #000;
        }
        
        .audio-controls button.active {
            background: #00ff00;
            color: #000;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="overlay">
        <div class="scanline"></div>
        
        <div class="glitch" id="title">
            HACK THE PLANET
        </div>
        
        <div class="matrix-text" id="matrixText">
            <div>INITIALIZING NEURAL NETWORK...</div>
            <div>ACCESSING MAINFRAME...</div>
            <div>BREACHING FIREWALL...</div>
            <div>DOWNLOADING DATA...</div>
        </div>
        
        <div class="terminal" id="terminal">
            <div>root@hackers:~$ whoami</div>
            <div>zero_cool</div>
            <div>root@hackers:~$ date</div>
            <div id="currentDate"></div>
            <div>root@hackers:~$ <span class="cursor">█</span></div>
        </div>
        
        <div class="audio-controls">
            <div>MIDI AUDIO SYSTEM</div>
            <div id="audioStatus">CLICK TO ENABLE AUDIO</div>
            <button id="playBtn">PLAY</button>
            <button id="stopBtn">STOP</button>
            <button id="volBtn">VOL: 50%</button>
            <button id="patternBtn">PATTERN: 1</button>
        </div>
    </div>

    <script>
        // MIDI Synthesizer for Cyberpunk Soundtrack
        class CyberpunkMIDI {
            constructor() {
                this.audioContext = null;
                this.isPlaying = false;
                this.volume = 0.5;
                this.tempo = 140; // BPM - Classic 90s electronic tempo
                this.currentBeat = 0;
                this.patterns = {};
                this.additionalPatterns = {};
                this.oscillators = [];
                this.gainNode = null;
                this.masterGain = null;
                this.patternSet = 0; // 0 = main patterns, 1 = additional patterns
            }
            
            async init() {
                try {
                    // Use the correct AudioContext constructor for all browsers
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (!AudioContext) {
                        console.log('Web Audio API not supported');
                        return false;
                    }
                    
                    this.audioContext = new AudioContext();
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.connect(this.audioContext.destination);
                    this.masterGain.gain.value = this.volume;
                    
                    // Create synthesizer patterns inspired by Hackers soundtrack
                    this.createCyberpunkPatterns();
                    
                    console.log('Audio context initialized successfully, state:', this.audioContext.state);
                    return true;
                } catch (error) {
                    console.log('Audio not available:', error);
                    return false;
                }
            }
            
            async resumeAudioContext() {
                if (!this.audioContext) {
                    console.log('No audio context available');
                    return false;
                }
                
                try {
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                        console.log('Audio context resumed, new state:', this.audioContext.state);
                    }
                    
                    // Ensure we have a valid audio context
                    if (this.audioContext.state === 'running') {
                        return true;
                    } else {
                        console.log('Audio context state:', this.audioContext.state);
                        return false;
                    }
                } catch (error) {
                    console.log('Failed to resume audio context:', error);
                    return false;
                }
            }
            
            createCyberpunkPatterns() {
                // Authentic patterns inspired by actual Hackers soundtrack tracks
                this.patterns = {
                    // Orbital "Halcyon" inspired bass line
                    bass: [36, 0, 36, 0, 36, 0, 36, 0, 36, 0, 36, 0, 36, 0, 36, 0],
                    
                    // Underworld "Born Slippy" inspired lead melody
                    lead: [60, 0, 64, 0, 67, 0, 72, 0, 75, 0, 72, 0, 67, 0, 64, 0],
                    
                    // Orbital "Halcyon" inspired pad chords
                    pad: [48, 0, 0, 0, 55, 0, 0, 0, 60, 0, 0, 0, 67, 0, 0, 0],
                    
                    // Prodigy "Voodoo People" inspired drums
                    drums: [38, 0, 42, 0, 38, 0, 42, 0, 38, 0, 42, 0, 38, 0, 42, 0],
                    
                    // Orbital "Halcyon" inspired arpeggio (the iconic sequence)
                    arp: [72, 76, 79, 84, 79, 76, 72, 67, 72, 76, 79, 84, 79, 76, 72, 67]
                };
                
                // Add more authentic tracks inspired by the soundtrack
                this.createAdditionalTracks();
            }
            
            createAdditionalTracks() {
                // Additional patterns for more variety
                this.additionalPatterns = {
                    // Stereo MCs "Connected" inspired bass
                    bass2: [36, 36, 0, 36, 36, 36, 0, 36, 36, 36, 0, 36, 36, 36, 0, 36],
                    
                    // Leftfield "Open Up" inspired lead
                    lead2: [60, 64, 67, 0, 72, 0, 67, 64, 60, 0, 64, 67, 72, 0, 67, 64],
                    
                    // The Chemical Brothers inspired pad
                    pad2: [48, 51, 55, 58, 60, 63, 67, 70, 72, 75, 79, 82, 84, 87, 91, 94],
                    
                    // Alternating drum patterns
                    drums2: [38, 42, 0, 42, 38, 0, 42, 0, 38, 42, 38, 42, 0, 42, 38, 0]
                };
            }
            
            async play() {
                if (!this.audioContext || this.isPlaying) return;
                
                // Resume audio context if suspended (required by modern browsers)
                const resumed = await this.resumeAudioContext();
                if (!resumed) {
                    console.log('Cannot play audio - context not resumed');
                    return;
                }
                
                this.isPlaying = true;
                this.currentBeat = 0;
                this.startSequencer();
            }
            
            stop() {
                this.isPlaying = false;
                this.oscillators.forEach(osc => {
                    if (osc) osc.stop();
                });
                this.oscillators = [];
            }
            
            startSequencer() {
                if (!this.isPlaying) return;
                
                const beatDuration = (60 / this.tempo) * 4; // 16th note duration
                
                // Switch pattern sets every 32 beats (2 bars)
                if (this.currentBeat % 32 === 0 && this.currentBeat > 0) {
                    this.patternSet = (this.patternSet + 1) % 2;
                    console.log(`Switching to pattern set ${this.patternSet}`);
                }
                
                // Get current pattern set
                const currentPatterns = this.patternSet === 0 ? this.patterns : this.additionalPatterns;
                
                // Play all patterns
                Object.keys(currentPatterns).forEach((patternName, index) => {
                    const note = currentPatterns[patternName][this.currentBeat % currentPatterns[patternName].length];
                    if (note > 0) {
                        console.log(`Playing note ${note} for ${patternName} (set ${this.patternSet})`);
                        this.playNote(note, patternName, index * 0.1);
                    }
                });
                
                this.currentBeat++;
                setTimeout(() => this.startSequencer(), beatDuration * 1000);
            }
            
            playNote(midiNote, instrument, delay = 0) {
                if (!this.audioContext || this.audioContext.state !== 'running') {
                    console.log('Audio context not ready for playback');
                    return;
                }
                
                const frequency = 440 * Math.pow(2, (midiNote - 69) / 12);
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                // Different waveforms for different instruments
                let waveform = 'sine';
                let attack = 0.01;
                let decay = 0.3;
                let sustain = 0.7;
                let release = 0.5;
                
                switch (instrument) {
                    case 'bass':
                        waveform = 'sawtooth';
                        attack = 0.05;
                        decay = 0.1;
                        sustain = 0.9;
                        release = 0.15;
                        break;
                    case 'lead':
                        waveform = 'square';
                        attack = 0.02;
                        decay = 0.05;
                        sustain = 0.95;
                        release = 0.1;
                        break;
                    case 'pad':
                        waveform = 'triangle';
                        attack = 0.2;
                        decay = 0.2;
                        sustain = 0.9;
                        release = 0.5;
                        break;
                    case 'drums':
                        waveform = 'square';
                        attack = 0.001;
                        decay = 0.05;
                        sustain = 0.0;
                        release = 0.05;
                        break;
                    case 'arp':
                        waveform = 'sine';
                        attack = 0.005;
                        decay = 0.05;
                        sustain = 0.8;
                        release = 0.1;
                        break;
                }
                
                oscillator.type = waveform;
                oscillator.frequency.value = frequency;
                
                // ADSR envelope
                const now = this.audioContext.currentTime + delay;
                const totalDuration = attack + decay + release;
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(sustain, now + attack);
                gainNode.gain.linearRampToValueAtTime(sustain * 0.7, now + attack + decay);
                gainNode.gain.linearRampToValueAtTime(0, now + totalDuration);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.masterGain);
                
                oscillator.start(now);
                oscillator.stop(now + totalDuration);
                
                // Clean up oscillator after it finishes
                oscillator.onended = () => {
                    const index = this.oscillators.indexOf(oscillator);
                    if (index > -1) {
                        this.oscillators.splice(index, 1);
                    }
                };
                
                this.oscillators.push(oscillator);
            }
            
            setVolume(volume) {
                this.volume = Math.max(0, Math.min(1, volume));
                if (this.masterGain) {
                    this.masterGain.gain.value = this.volume;
                }
            }
        }

        class HackersTribute {
            constructor() {
                console.log('Initializing HackersTribute...');
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.time = 0;
                this.particles = [];
                this.wireframe = [];
                this.plasma = [];
                this.matrix = [];
                this.midi = new CyberpunkMIDI();
                
                console.log('Canvas:', this.canvas, 'Context:', this.ctx);
                
                this.init();
                this.createParticles();
                this.createWireframe();
                this.createMatrix();
                this.setupAudioControls();
                this.animate();
                
                // Update date
                document.getElementById('currentDate').textContent = new Date().toLocaleString();
                console.log('HackersTribute initialized successfully');
            }
            
            init() {
                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                // Add some interactive elements
                this.canvas.addEventListener('click', () => this.explosion());
                this.canvas.addEventListener('mousemove', (e) => this.mouseMove(e));
                
                // Initialize MIDI
                this.midi.init().then(success => {
                    if (!success) {
                        document.getElementById('audioStatus').textContent = 'AUDIO UNAVAILABLE';
                    }
                });
                
                // Add global click handler to enable audio
                document.addEventListener('click', async () => {
                    if (this.midi.audioContext && this.midi.audioContext.state === 'suspended') {
                        await this.midi.resumeAudioContext();
                        if (this.midi.audioContext.state === 'running') {
                            document.getElementById('audioStatus').textContent = 'AUDIO ENABLED';
                        }
                    }
                }, { once: false });
            }
            
            setupAudioControls() {
                const playBtn = document.getElementById('playBtn');
                const stopBtn = document.getElementById('stopBtn');
                const volBtn = document.getElementById('volBtn');
                const patternBtn = document.getElementById('patternBtn');
                const audioStatus = document.getElementById('audioStatus');
                
                console.log('Setting up audio controls:', { playBtn, stopBtn, volBtn, audioStatus });
                
                if (!playBtn || !stopBtn || !volBtn || !patternBtn) {
                    console.error('Audio control buttons not found!');
                    return;
                }
                
                playBtn.addEventListener('click', async (e) => {
                    console.log('Play button clicked!', e);
                    e.preventDefault();
                    e.stopPropagation();
                    
                    if (this.midi.isPlaying) {
                        this.midi.stop();
                        playBtn.textContent = 'PLAY';
                        playBtn.classList.remove('active');
                        audioStatus.textContent = 'STOPPED';
                    } else {
                        audioStatus.textContent = 'INITIALIZING...';
                        await this.midi.play();
                        if (this.midi.isPlaying) {
                            playBtn.textContent = 'PAUSE';
                            playBtn.classList.add('active');
                            audioStatus.textContent = 'PLAYING';
                        } else {
                            audioStatus.textContent = 'ERROR - CLICK TO ENABLE';
                        }
                    }
                });
                
                stopBtn.addEventListener('click', (e) => {
                    console.log('Stop button clicked!', e);
                    e.preventDefault();
                    e.stopPropagation();
                    this.midi.stop();
                    playBtn.textContent = 'PLAY';
                    playBtn.classList.remove('active');
                    audioStatus.textContent = 'STOPPED';
                });
                
                volBtn.addEventListener('click', (e) => {
                    console.log('Volume button clicked!', e);
                    e.preventDefault();
                    e.stopPropagation();
                    const volumes = [0, 0.25, 0.5, 0.75, 1.0];
                    const currentVol = this.midi.volume;
                    const currentIndex = volumes.indexOf(currentVol);
                    const nextIndex = (currentIndex + 1) % volumes.length;
                    const newVol = volumes[nextIndex];
                    
                    this.midi.setVolume(newVol);
                    volBtn.textContent = `VOL: ${Math.round(newVol * 100)}%`;
                });
                
                patternBtn.addEventListener('click', (e) => {
                    console.log('Pattern button clicked!', e);
                    e.preventDefault();
                    e.stopPropagation();
                    this.midi.patternSet = (this.midi.patternSet + 1) % 2;
                    patternBtn.textContent = `PATTERN: ${this.midi.patternSet + 1}`;
                    console.log(`Manually switched to pattern set ${this.midi.patternSet}`);
                });
            }
            
            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                console.log('Canvas resized to:', this.canvas.width, 'x', this.canvas.height);
            }
            
            createParticles() {
                for (let i = 0; i < 200; i++) {
                    this.particles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        life: Math.random() * 100,
                        maxLife: 100,
                        size: Math.random() * 3 + 1
                    });
                }
            }
            
            createWireframe() {
                // Create a 3D wireframe cube
                const size = 100;
                const vertices = [
                    [-size, -size, -size], [size, -size, -size], [size, size, -size], [-size, size, -size],
                    [-size, -size, size], [size, -size, size], [size, size, size], [-size, size, size]
                ];
                
                const edges = [
                    [0,1], [1,2], [2,3], [3,0], // front face
                    [4,5], [5,6], [6,7], [7,4], // back face
                    [0,4], [1,5], [2,6], [3,7]  // connecting edges
                ];
                
                this.wireframe = { vertices, edges };
            }
            
            createMatrix() {
                const chars = '01アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン';
                for (let i = 0; i < 50; i++) {
                    this.matrix.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        char: chars[Math.floor(Math.random() * chars.length)],
                        speed: Math.random() * 2 + 1,
                        life: Math.random() * 100
                    });
                }
            }
            
            mouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Create particles at mouse position
                for (let i = 0; i < 5; i++) {
                    this.particles.push({
                        x: mouseX + (Math.random() - 0.5) * 20,
                        y: mouseY + (Math.random() - 0.5) * 20,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 60,
                        maxLife: 60,
                        size: Math.random() * 2 + 1
                    });
                }
            }
            
            explosion() {
                // Create explosion effect
                for (let i = 0; i < 100; i++) {
                    const angle = (Math.PI * 2 * i) / 100;
                    this.particles.push({
                        x: this.canvas.width / 2,
                        y: this.canvas.height / 2,
                        vx: Math.cos(angle) * 8,
                        vy: Math.sin(angle) * 8,
                        life: 80,
                        maxLife: 80,
                        size: Math.random() * 4 + 2
                    });
                }
            }
            
            drawPlasma(musicIntensity = 1.0) {
                const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                for (let y = 0; y < this.canvas.height; y += 2) {
                    for (let x = 0; x < this.canvas.width; x += 2) {
                        const index = (y * this.canvas.width + x) * 4;
                        
                        const timeMultiplier = 0.01 * musicIntensity;
                        const value1 = Math.sin((x * 0.01) + this.time * timeMultiplier);
                        const value2 = Math.sin((y * 0.01) + this.time * timeMultiplier);
                        const value3 = Math.sin(((x + y) * 0.01) + this.time * timeMultiplier);
                        const value4 = Math.sin((Math.sqrt(x * x + y * y) * 0.01) + this.time * timeMultiplier);
                        
                        const value = (value1 + value2 + value3 + value4) / 4;
                        
                        const r = Math.floor((Math.sin(value * Math.PI) + 1) * 127 * musicIntensity);
                        const g = Math.floor((Math.sin(value * Math.PI + 2) + 1) * 127 * musicIntensity);
                        const b = Math.floor((Math.sin(value * Math.PI + 4) + 1) * 127 * musicIntensity);
                        
                        data[index] = Math.min(255, r);
                        data[index + 1] = Math.min(255, g);
                        data[index + 2] = Math.min(255, b);
                        data[index + 3] = 200; // More visible plasma
                    }
                }
                
                this.ctx.putImageData(imageData, 0, 0);
            }
            
            drawWireframe(beatSync = 0) {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const rotation = this.time * 0.01 + (beatSync * 0.1);
                
                // Pulsing effect synchronized with beat
                const pulseIntensity = Math.sin(beatSync * Math.PI / 8) * 0.5 + 0.5;
                this.ctx.strokeStyle = `rgba(0, 255, 0, ${1.0})`;
                this.ctx.lineWidth = 3 + pulseIntensity;
                this.ctx.shadowColor = '#00ff00';
                this.ctx.shadowBlur = 10;
                this.ctx.beginPath();
                
                const vertices = this.wireframe.vertices.map(vertex => {
                    const [x, y, z] = vertex;
                    const rotatedX = x * Math.cos(rotation) - z * Math.sin(rotation);
                    const rotatedZ = x * Math.sin(rotation) + z * Math.cos(rotation);
                    const rotatedY = y * Math.cos(rotation * 0.7) - rotatedZ * Math.sin(rotation * 0.7);
                    
                    const scale = 300 / (300 + rotatedZ);
                    const screenX = centerX + rotatedX * scale;
                    const screenY = centerY + rotatedY * scale;
                    
                    return [screenX, screenY];
                });
                
                this.wireframe.edges.forEach(edge => {
                    const [start, end] = edge;
                    const [x1, y1] = vertices[start];
                    const [x2, y2] = vertices[end];
                    
                    this.ctx.moveTo(x1, y1);
                    this.ctx.lineTo(x2, y2);
                });
                
                this.ctx.stroke();
                this.ctx.shadowBlur = 0; // Reset shadow
            }
            
            drawParticles() {
                this.particles.forEach((particle, index) => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.life--;
                    
                    if (particle.life <= 0 || particle.x < 0 || particle.x > this.canvas.width || 
                        particle.y < 0 || particle.y > this.canvas.height) {
                        this.particles.splice(index, 1);
                        return;
                    }
                    
                    const alpha = particle.life / particle.maxLife;
                    this.ctx.fillStyle = `rgba(0, 255, 0, ${alpha})`;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }
            
            drawMatrix() {
                this.ctx.font = '12px Courier New';
                this.ctx.fillStyle = '#00ff00';
                
                this.matrix.forEach(char => {
                    char.y += char.speed;
                    char.life--;
                    
                    if (char.y > this.canvas.height || char.life <= 0) {
                        char.y = -20;
                        char.x = Math.random() * this.canvas.width;
                        char.life = Math.random() * 100 + 50;
                    }
                    
                    const alpha = char.life / 150;
                    this.ctx.globalAlpha = alpha;
                    this.ctx.fillText(char.char, char.x, char.y);
                });
                
                this.ctx.globalAlpha = 1;
            }
            
            drawTunnel(musicIntensity = 1.0) {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const maxRadius = Math.max(this.canvas.width, this.canvas.height) / 2;
                
                for (let i = 0; i < 50; i++) {
                    const radius = (i / 50) * maxRadius;
                    const angle = (this.time * 0.02 * musicIntensity) + (i * 0.1);
                    
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    const alpha = (1 - i / 50) * musicIntensity;
                    this.ctx.strokeStyle = `rgba(0, 255, 0, ${alpha})`;
                    this.ctx.lineWidth = 2 * musicIntensity;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 2 * musicIntensity, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
            }
            
            animate() {
                this.time++;
                
                // Sync visual intensity with music
                const musicIntensity = this.midi.isPlaying ? 1.5 : 1.0;
                const beatSync = this.midi.currentBeat % 16;
                
                // Clear canvas with fade effect
                this.ctx.fillStyle = `rgba(0, 0, 0, ${0.1 / musicIntensity})`;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw effects in layers with music sync
                try {
                    this.drawPlasma(musicIntensity);
                    this.drawWireframe(beatSync);
                    this.drawTunnel(musicIntensity);
                    this.drawParticles();
                    this.drawMatrix();
                } catch (error) {
                    console.error('Error in animation loop:', error);
                }
                
                // Enhanced glitch effects when music is playing
                if (this.midi.isPlaying && Math.random() < 0.05) {
                    this.glitchEffect();
                } else if (!this.midi.isPlaying && Math.random() < 0.02) {
                    this.glitchEffect();
                }
                
                requestAnimationFrame(() => this.animate());
            }
            
            glitchEffect() {
                const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                // Randomly shift some pixel rows
                for (let i = 0; i < 10; i++) {
                    const row = Math.floor(Math.random() * this.canvas.height);
                    const shift = Math.floor((Math.random() - 0.5) * 50);
                    
                    for (let x = 0; x < this.canvas.width; x++) {
                        const sourceIndex = (row * this.canvas.width + x) * 4;
                        const targetIndex = (row * this.canvas.width + ((x + shift + this.canvas.width) % this.canvas.width)) * 4;
                        
                        data[targetIndex] = data[sourceIndex];
                        data[targetIndex + 1] = data[sourceIndex + 1];
                        data[targetIndex + 2] = data[sourceIndex + 2];
                    }
                }
                
                this.ctx.putImageData(imageData, 0, 0);
            }
        }
        
        // Initialize the tribute when page loads
        window.addEventListener('load', () => {
            console.log('Window loaded, initializing HackersTribute...');
            try {
                new HackersTribute();
            } catch (error) {
                console.error('Error initializing HackersTribute:', error);
            }
        });
        
        // Easter egg: Konami code
        let konamiCode = [];
        const konamiSequence = [38, 38, 40, 40, 37, 39, 37, 39, 66, 65]; // ↑↑↓↓←→←→BA
        
        document.addEventListener('keydown', (e) => {
            konamiCode.push(e.keyCode);
            if (konamiCode.length > konamiSequence.length) {
                konamiCode.shift();
            }
            
            if (konamiCode.join(',') === konamiSequence.join(',')) {
                alert('ACCESS GRANTED\n\n"Mess with the best, die like the rest!"\n\n- Zero Cool');
                konamiCode = [];
            }
        });
    </script>
</body>
</html>
